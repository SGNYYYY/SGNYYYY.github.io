<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sam&#39;s Blog</title>
  
  <subtitle>Hi There is Sam&#39;s Blogs</subtitle>
  <link href="https://sgnyyyy.github.io/atom.xml" rel="self"/>
  
  <link href="https://sgnyyyy.github.io/"/>
  <updated>2025-05-07T10:20:56.943Z</updated>
  <id>https://sgnyyyy.github.io/</id>
  
  <author>
    <name>SGNYYYY</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>简单DNS客户端编写</title>
    <link href="https://sgnyyyy.github.io/2025/05/07/%E7%AE%80%E5%8D%95DNS%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%96%E5%86%99/"/>
    <id>https://sgnyyyy.github.io/2025/05/07/%E7%AE%80%E5%8D%95DNS%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BC%96%E5%86%99/</id>
    <published>2025-05-07T10:20:34.000Z</published>
    <updated>2025-05-07T10:20:56.943Z</updated>
    
    
    
    
    <category term="DNS" scheme="https://sgnyyyy.github.io/categories/DNS/"/>
    
    
  </entry>
  
  <entry>
    <title>DNS基本工具</title>
    <link href="https://sgnyyyy.github.io/2025/05/07/DNS%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7/"/>
    <id>https://sgnyyyy.github.io/2025/05/07/DNS%E5%9F%BA%E6%9C%AC%E5%B7%A5%E5%85%B7/</id>
    <published>2025-05-07T10:20:26.000Z</published>
    <updated>2025-05-07T15:46:47.684Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DNS基本工具"><a href="#DNS基本工具" class="headerlink" title="DNS基本工具"></a>DNS基本工具</h2><h3 id="使用命令行工具如dig、nslookup进行DNS查询"><a href="#使用命令行工具如dig、nslookup进行DNS查询" class="headerlink" title="使用命令行工具如dig、nslookup进行DNS查询"></a>使用命令行工具如dig、nslookup进行DNS查询</h3><h3 id="dig"><a href="#dig" class="headerlink" title="dig"></a>dig</h3><p>参考 <a href="https://www.sysgeek.cn/linux-dig/">系统极客</a></p><p>dig 命令可以查询各种类型 DNS 记录信息，包括：主机名称记录（A、AAAA）、邮件交换记录（MX）和别名记录（CNAME）等等。由于其灵活性和易用性，它是系统管理员解决 DNS 问题时最常用的工具。</p><blockquote><h4 id="验证是否安装dig"><a href="#验证是否安装dig" class="headerlink" title="验证是否安装dig"></a>验证是否安装dig</h4></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig -v</span><br></pre></td></tr></table></figure><blockquote><h4 id="dig命令语法"><a href="#dig命令语法" class="headerlink" title="dig命令语法"></a>dig命令语法</h4></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig [server] [name] [type]</span><br></pre></td></tr></table></figure><ul><li>[server]查询指向的主机名或 IP 地址</li><li>[name]要查询服务器的 DNS（域名服务器）</li><li>[type]要检索的 DNS 记录类型。默认情况下（或如果留空），dig 查询 A 记录。</li></ul><blockquote><h4 id="dig命令输出"><a href="#dig命令输出" class="headerlink" title="dig命令输出"></a>dig命令输出</h4></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig www.aliyun.com</span><br></pre></td></tr></table></figure><p><img src="/images/dns/dig_output.png" alt="dig_output"></p><p>第一行显示 dig 命令的版本，以及查询的域名；</p><p>第二行显示全局选项（默认情况下，仅有 cmd）</p><p><code>HEADER</code>部分显示从被请求机构（DNS 服务器）收到响应的详细技术信息。标题显示由 dig 执行操作的「操作码」和「操作状态」的「标头」，上述示例中的「操作状态」是NOERROR，这意味着被请求的 DNS 服务器可以没有任何阻碍地提供查询。<br>Flags是回答格式的参考。</p><p><code>OPT PSEUDOSECTION</code>显示高级数据</p><ul><li><code>EDNS </code>DNS 的扩展机制</li><li><code>Flags</code> 未指定标志时为空</li><li><code>UDP</code> UDP 数据包大小</li></ul><p><code>QUESTION</code>部分显示发送的查询数据：</p><ul><li>第一列是查询的域名</li><li>第二列是查询的类型（IN 表示互联网）</li><li>第三列指定了记录类型（如果未指定则默查询 A 记录）</li></ul><p>最重要的部分是<code>ANSWER</code>部分：</p><ul><li>第一列列出了被查询的服务器名称</li><li>第二列是 <code>TTL</code>（存活时间），在此之后记录将被刷新</li><li>第三列显示查询的类别 – 在本例中，<code>IN</code>代表互联网</li><li>第四列显示查询的类型 – 在本例中，<code>CNAME</code>代表 CNAME（别名）记录，<code>A</code>代表 A（地址）记录</li><li>最后一列显示与域名关联的别名和 IP 地址（结果）</li></ul><p>最后的<code>STATISTICS</code>统计信息部分显示关于查询的元数据:</p><ul><li><code>Query time</code>响应花费的时间</li><li><code>SERVER</code> 响应 DNS 服务器的 IP 地址和端口</li><li><code>WHEN</code>命令运行的时间戳</li><li><code>MSG SIZE rcvd</code>从 DNS 服务器收到的回复大小</li></ul><blockquote><h4 id="指定DNS服务器"><a href="#指定DNS服务器" class="headerlink" title="指定DNS服务器"></a>指定DNS服务器</h4></blockquote><p>默认情况下，如果未指定名称服务器，dig 命令会使用&#x2F;etc&#x2F;resolv.conf文件中列出的服务器进行查询。</p><p>要指定 DNS 服务器进行查询，可以使用@后跟 DNS 服务器 IP 地址的方式来手动指定 DNS 服务器。</p><p>例如，要使用 阿里云 DNS 的233.5.5.5查询<a href="http://www.aliyun.com域名,可以使用如下/">www.aliyun.com域名，可以使用如下</a> 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig www.aliyun.com @233.5.5.5</span><br></pre></td></tr></table></figure><blockquote><h4 id="仅输出响应结果"><a href="#仅输出响应结果" class="headerlink" title="仅输出响应结果"></a>仅输出响应结果</h4></blockquote><p>在绝大多数情况下，只使用 dig 查询相应的 DNS 记录，而不需要太多复杂的、不相关的响应和输出。此时就可以使用以下两种方式。</p><ul><li>输出简短结果</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig www.aliyun.com +short</span><br></pre></td></tr></table></figure><ul><li>输出详细响应，先使用<code>+noall</code>参数关闭所有结果，再使用<code>+answer</code>参数打开结果部分。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig www.aliyun.com +noall +answer</span><br></pre></td></tr></table></figure><blockquote><h4 id="使用dig命令查询特定记录类型"><a href="#使用dig命令查询特定记录类型" class="headerlink" title="使用dig命令查询特定记录类型"></a>使用dig命令查询特定记录类型</h4></blockquote><ul><li>查询A记录，要获取域名的所有 IP 地址列表，请使用a参数：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig +nocmd www.aliyun.com a +noall +answer</span><br></pre></td></tr></table></figure><p><img src="/images/dns/dig_a.png" alt="dig_a"></p><ul><li>查询CNAME记录<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig +nocmd www.aliyun.com cname +noall +answer</span><br></pre></td></tr></table></figure></li></ul><p><img src="/images/dns/dig_cname.png" alt="dig_cname"></p><ul><li>查询TXT记录，使用<code>txt</code>参数检索特定域的所有「TXT 记录」：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig +nocmd aliyun.com txt +noall +answer</span><br></pre></td></tr></table></figure><img src="/images/dns/dig_txt.png" alt="dig_txt"></li><li>查询MX记录，获取特定域的所有邮件交换记录<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig +nocmd aliyun.com mx +noall +answer</span><br></pre></td></tr></table></figure><img src="/images/dns/dig_mx.png" alt="dig_mx"></li><li>查询NS记录，查找特定域的权威名称服务器<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig +nocmd aliyun.com ns +noall +answer</span><br></pre></td></tr></table></figure><img src="/images/dns/dig_ns.png" alt="dig_ns"></li></ul><blockquote><h4 id="使用-dig-命令进行-PTR-反向-DNS-查询"><a href="#使用-dig-命令进行-PTR-反向-DNS-查询" class="headerlink" title="使用 dig 命令进行 PTR 反向 DNS 查询"></a>使用 dig 命令进行 PTR 反向 DNS 查询</h4><p>要查询与特定 IP 地址关联的主机名，请使用-x参数。</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig -x 208.118.235.148 +noall +answer</span><br></pre></td></tr></table></figure><p><img src="/images/dns/dig_ptr.png" alt="dig_ptr"></p><blockquote><h4 id="Trace-参数"><a href="#Trace-参数" class="headerlink" title="Trace 参数"></a>Trace 参数</h4><p><code>+trace</code>参数可以列出查询经过的不同 DNS 服务器，直到最终目的地。可以使用此参数来确定流量中断的 IP 地址:</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig aliyun.com +trace</span><br></pre></td></tr></table></figure><blockquote><h4 id="dig-命令批量-DNS-查询"><a href="#dig-命令批量-DNS-查询" class="headerlink" title="dig 命令批量 DNS 查询"></a>dig 命令批量 DNS 查询</h4><p>如果要对大量域名进行 DNS 查询，可以将其全部写入到一个文本文件中（一行一个），然后使用-f参数，再跟止文件名即可，例如：</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dig -f domains.txt +short</span><br></pre></td></tr></table></figure><blockquote><h4 id="digrc-文件"><a href="#digrc-文件" class="headerlink" title=".digrc 文件"></a>.digrc 文件</h4><p>还可通过不同用户的${HOME}&#x2F;.digrc文件来控制 dig 命令的行为，如果.digrc文件存在于用户的主目录中，则 dig 可以读取其中的参数，而无需用户在执行命令时手动添加。例如，直接在~&#x2F;.digrc文件中写入+nocmd +noall +answer参数。</p></blockquote><h3 id="nslookup"><a href="#nslookup" class="headerlink" title="nslookup"></a>nslookup</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure><h3 id="常见的DNS系统（如：Bind、PowerDNS等）及相关软件特性"><a href="#常见的DNS系统（如：Bind、PowerDNS等）及相关软件特性" class="headerlink" title="常见的DNS系统（如：Bind、PowerDNS等）及相关软件特性"></a>常见的DNS系统（如：Bind、PowerDNS等）及相关软件特性</h3><h4 id="Bind"><a href="#Bind" class="headerlink" title="Bind"></a>Bind</h4><h4 id="PowerDNS"><a href="#PowerDNS" class="headerlink" title="PowerDNS"></a>PowerDNS</h4><h3 id="编程语言中常用的相关库（Go-Java）"><a href="#编程语言中常用的相关库（Go-Java）" class="headerlink" title="编程语言中常用的相关库（Go, Java）"></a>编程语言中常用的相关库（Go, Java）</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;DNS基本工具&quot;&gt;&lt;a href=&quot;#DNS基本工具&quot; class=&quot;headerlink&quot; title=&quot;DNS基本工具&quot;&gt;&lt;/a&gt;DNS基本工具&lt;/h2&gt;&lt;h3 id=&quot;使用命令行工具如dig、nslookup进行DNS查询&quot;&gt;&lt;a href=&quot;#使用命令行工</summary>
      
    
    
    
    <category term="DNS" scheme="https://sgnyyyy.github.io/categories/DNS/"/>
    
    
  </entry>
  
  <entry>
    <title>DNS基础知识</title>
    <link href="https://sgnyyyy.github.io/2025/05/06/DNS%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"/>
    <id>https://sgnyyyy.github.io/2025/05/06/DNS%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</id>
    <published>2025-05-06T05:40:06.000Z</published>
    <updated>2025-05-07T14:34:18.484Z</updated>
    
    <content type="html"><![CDATA[<h2 id="DNS基本概念"><a href="#DNS基本概念" class="headerlink" title="DNS基本概念"></a>DNS基本概念</h2><h3 id="DNS的主要功能"><a href="#DNS的主要功能" class="headerlink" title="DNS的主要功能"></a>DNS的主要功能</h3><p>DNS（Domain Name System）是因特网的一项服务，它作为<strong>域名和IP地址相互映射</strong>的一个<strong>分布式数据库</strong>，能够使人更方便的访问互联网。</p><p>解析域名：将域名解析成相应的IP地址</p><p>域名管理：管理互联网上的所有域名，包括注册、续费、修改、删除等操作。</p><p>负载均衡：将请求分发到不同的服务器上，实现负载均衡和高可用性。</p><p>在底层原理方面，DNS服务主要依赖于分布式数据库系统和递归查询机制。具体来说，DNS服务将所有的域名和IP地址存储在一个分布式的数据库系统中，每个DNS服务器都存储了一部分数据。当用户输入一个域名时，本地DNS服务器会先进行查询，如果本地DNS服务器没有相应的记录，则会向根域名服务器发送请求。根域名服务器将返回一个指向相应顶级域名服务器的IP地址。然后本地DNS服务器再向顶级域名服务器发送请求，顶级域名服务器会返回一个指向相应二级域名服务器的IP地址，以此类推，直到最终得到目标域名的IP地址。</p><p>需要注意的是，DNS查询过程中采用的是递归查询机制，即本地DNS服务器会向根域名服务器、顶级域名服务器、二级域名服务器等逐层发送查询请求，直到得到目标域名的IP地址为止。这种查询方式可以保证数据的安全性和可靠性，同时也可以防止DNS攻击和DNS污染等安全问题。</p><h3 id="DNS结构层次"><a href="#DNS结构层次" class="headerlink" title="DNS结构层次"></a>DNS结构层次</h3><p>域名的层次结构：</p><ul><li>根域，域名空间最顶层，一般用一个’.’表示</li><li>顶级域，代表一种类型的组织机构或者国家地区</li><li>二级域，标明顶级域内的的一个特定组织</li><li>子域，二级域下所创建的各级域统称为子域</li><li>主机，域名空间最下层，就是一台具体的计算机</li></ul><p>顶级域名（TLD）、二级域名、子域名的概念：</p><ul><li>顶级域名：Top-level domains（TLD）</li><li>二级域名：Second-level domain（SLD），处于顶级域名之下的域。二级域名是域名的倒数第二个部分</li><li>子域名：Subdomain，凡顶级域名前加前缀的都是该顶级域名的子域名，而子域名根据技术的多少分为二级子域名，三级子域名以及多级子域名。</li></ul><h3 id="DNS记录类型"><a href="#DNS记录类型" class="headerlink" title="DNS记录类型"></a>DNS记录类型</h3><p>A记录、AAAA记录、CNAME记录、MX记录、NS记录、TXT记录等</p><p>各种记录的作用与使用场景：</p><ul><li><p>A记录，Address，也称主机记录，一个主机域名对应的ipv4地址</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">www.baidu.com. IN A 1.1.1.2</span><br><span class="line">mx1.baidu.com. IN A 1.1.1.3</span><br></pre></td></tr></table></figure></li><li><p>AAAA记录，一个主机域名对应的ipv6记录</p></li><li><p>CNAME记录，Canonical Name，别名记录，让一个服务器有多个域名</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">web.sangfor.com. IN CNAME www.sanfor.com.</span><br></pre></td></tr></table></figure></li><li><p>MX记录，Mail Exchanger 邮件交换记录，用于说明哪台服务器是当前区域的邮件服务器，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">magedu.com. IN MX 10 mx1.magedu.com.</span><br><span class="line">IN MX 20 mx2.magedu.com.</span><br></pre></td></tr></table></figure></li><li><p>NS记录，Name Server，域名服务器记录，用来指定该域名由哪个DNS服务器来解析，NS记录依赖A记录的解析，NS记录说明，在这个区域里，有多少个服务器承担解析的任务</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">baidu.com. IN NS ns1.baidu.com.</span><br><span class="line">baidu.com. IN NS ns2.baidu.com.</span><br></pre></td></tr></table></figure></li><li><p>TXT记录，一般指某个主机或域名的说明</p></li><li><p>PTR记录，逆向查询记录，用于从ip地址中查询域名。PTR记录是A记录的逆向记录</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4.3.2.1.in-addr.arpa IN PTR www.sangfor.com.</span><br></pre></td></tr></table></figure></li></ul><p>TTL（生存时间Time-To-Live）对DNS记录的影响：</p><p>TTL是IP协议包中的一个值，它告诉网络路由器包在网络中的时间是否太长而应被丢弃。TTL就是一条域名解析记录在DNS服务器中的存留时间。<br>TTL值设置大：节约域名解析时间，给网站访问加速<br>TTL值设置小：减少更换空间时的不可访问时间。更换空间99.9%会有DNS记录更改的问题，因为缓存的问题，新的域名记录在有的地方可能生效，但是在有的地方可能等到一两天甚至更久才生效。访问无所谓，但是涉及到邮件发送就比较麻烦。<br>一般操作系统的默认TTL值如下： TTL&#x3D;32 Windows 9x&#x2F;Me TTL&#x3D;64 LINUX TTL&#x3D;128 Windows 200x&#x2F;XP TTL&#x3D;255 Unix </p><h3 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h3><ol><li>用户输入网址，先查询本地DNS，本地DNS是一系列DNS的集合，比如ISP（Internet Service Provider）提供的DNS、公司网络提供的DNS。本地DNS是一个代理，将DNS请求转发到DNS网络中。如果本地DNS已经存在需要的记录，也就是本地DNS缓存中找到了对应的DNS条目，就会直接返回，而跳过之后的步骤</li><li>如果本地DNS服务器中没有对应的记录，那么请求回被转发到根DNS服务器。根DNS服务器只解析顶级域，例如”<a href="http://www.baidu.com&quot;,根服务器只查看com部分/">www.baidu.com&quot;,根服务器只查看com部分</a></li><li>根服务器返回顶级DNS服务器的IP</li><li>顶级域DNS服务器中存放的事二级域名的目录</li><li>顶级DNS服务器返回权威DNS服务器的IP</li><li>在权威服务器中存放具体的DNS记录</li><li>权威DNS服务器返回DNS记录到本地DNS服务器</li><li>本地DNS服务器返回具体的DNS记录给客户端</li></ol><h3 id="递归解析与迭代解析"><a href="#递归解析与迭代解析" class="headerlink" title="递归解析与迭代解析"></a>递归解析与迭代解析</h3><p><strong>递归算法</strong>只发出一次查询请求，要求服务器彻底地进行名字解析。当需要进一步查询时，本域名服务器向上级域名服务器返回其他域名服务器发出请求，直到查到记录。</p><p><strong>迭代查询</strong>可能发出多条请求，即上级域名服务器若返回的是其他域名服务器的地址，本域名服务器把这个地址发给用户，用户再进行深一级的查询。</p><p>DNS解析过程中： 223.5.5.5 是什么角色</p><p>在DNS解析过程中，223.5.5.5扮演的是公共DNS服务器的角色。它是由阿里云（Alibaba Cloud）提供的一个免费的DNS解析服务地址。当用户配置他们的网络设置以使用这个IP地址作为DNS服务器时，他们的DNS查询请求将会被发送到这个由阿里云运营的服务器。</p><h3 id="DNS安全"><a href="#DNS安全" class="headerlink" title="DNS安全"></a>DNS安全</h3><ol><li>常见的DNS攻击（如：DNS欺骗、缓存投毒等）：<br>DNS劫持（DNS Hijacking）：通过篡改DNS解析结果，讲用户引导至恶意网站。攻击者通过入侵DNS服务器或者用户的本地配置。<br>DNS缓存投毒（DNS Cache Poisoning）：攻击者通过向DNS服务器发送伪造的响应数据，污染其缓存，使得后续的DNS查询返回错误的IP地址<br>DNS放大攻击（DNS Amplification Attack）：是一种分布式拒绝服务（DDoS）攻击，攻击者利用开放的DNS服务器向目标发送大量伪造的查询请求，导致目标服务器因处理大量响应而瘫痪。攻击流量放大<br>DNS隧道攻击（DNS Tunneling Attack）：利用DNS协议进行数据泄漏或者绕过防火墙的技术。攻击者通过将数据编码到DNS查询和响应中，绕过传统的安全检查机制，实现隐蔽的数据传输。通常用于窃取敏感信息或者进行远程控制<br>DNS欺骗（DNS Spoofing）：攻击者伪造DNS响应，使得用户误以为访问的是合法网站，实际上却被引导至恶意站点。这种攻击通常与中间人攻击（MITM）结合使用，进一步窃取用户的敏感信息。</li><li>DNSSEC（DNS安全扩展）的基本概念：<br>DNSSEC（DNS安全扩展）是一种通过数字签名验证DNS响应真实性的技术。它可以有效防止DNS劫持、缓存投毒和欺骗攻击，确保用户访问的是合法的网站。</li></ol>]]></content>
    
    
    <summary type="html">DNS基础知识</summary>
    
    
    
    <category term="DNS" scheme="https://sgnyyyy.github.io/categories/DNS/"/>
    
    
  </entry>
  
  <entry>
    <title>Java常见手撕整理</title>
    <link href="https://sgnyyyy.github.io/2025/04/23/Java%E5%B8%B8%E8%A7%81%E6%89%8B%E6%92%95%E6%95%B4%E7%90%86/"/>
    <id>https://sgnyyyy.github.io/2025/04/23/Java%E5%B8%B8%E8%A7%81%E6%89%8B%E6%92%95%E6%95%B4%E7%90%86/</id>
    <published>2025-04-23T08:09:38.000Z</published>
    <updated>2025-05-07T10:21:43.794Z</updated>
    
    
    
    
    <category term="Java" scheme="https://sgnyyyy.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>素数筛</title>
    <link href="https://sgnyyyy.github.io/2025/03/14/%E7%B4%A0%E6%95%B0%E7%AD%9B/"/>
    <id>https://sgnyyyy.github.io/2025/03/14/%E7%B4%A0%E6%95%B0%E7%AD%9B/</id>
    <published>2025-03-13T16:38:35.000Z</published>
    <updated>2025-03-14T12:43:14.396Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一般筛法"><a href="#一般筛法" class="headerlink" title="一般筛法"></a>一般筛法</h3><p>从2到sqrt(n)判断有没有因子</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPrime</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>;i &lt;= <span class="built_in">sqrt</span>(n);i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n%i == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;一般筛法&quot;&gt;&lt;a href=&quot;#一般筛法&quot; class=&quot;headerlink&quot; title=&quot;一般筛法&quot;&gt;&lt;/a&gt;一般筛法&lt;/h3&gt;&lt;p&gt;从2到sqrt(n)判断有没有因子&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Java集合源码分析</title>
    <link href="https://sgnyyyy.github.io/2024/12/26/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>https://sgnyyyy.github.io/2024/12/26/Java%E9%9B%86%E5%90%88%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/</id>
    <published>2024-12-26T05:56:26.000Z</published>
    <updated>2025-05-07T10:21:47.407Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>底层是数组队列，与Java中的数组相比，它的容量可以动态增长。</p><p>继承于AbstractList, 实现了List，RandomAccess，Cloneable，java.io.Serializeable接口</p><p>可以存储任何类型的对象，包括null值，但是不建议向ArrayList添加null值</p><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><p>（JDK8）以无参数构造方法创建ArrayList时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为10。</p><p>扩容 grow()函数<br>先将新容量扩大为原来的1.5倍<br>判断新容量是否大于最小需要容量<br>如果小于，最小需要容量就作为新容量<br>判断新容量是否大于MAX_ARRAY_SIZE<br>如果大于，进入hugeCapacity()函数，比较最小需要容量和MAX_ARRAY_SIZE，如果最小需要容量大于MAX_ARRAY_SIZE，新容量为Integer.MAX_VALUE，否则，新容量为MAX_ARRAY_SIZE，即为Integer.MAX_VALUE-8</p><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>基于双向链表实现，项目中一般不会用到，需要用到LinkedList的场景几乎都可以用ArrayList代替。</p><p>LinkedList继承了AbstractSequentialList，而AbstractSequentialList又继承于AbstractList。实现了List，Deque，Cloneable，Serializable接口</p><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h3><p>基于哈希表的Map接口实现，非线程安全</p><p>可以存储null的key和value，但null作为键只能有一个，null作为值可以多个</p><p>JDK1.8之前，数组加链表，数组是主体，链表是为了解决哈希冲突存在的</p><p>通过key的hashCode经过扰动函数（HashMap的hash方法，防止一些实现比较差的hashCode（）方法，减少碰撞）处理后得到hash值，通过(n-1)&amp;hash判断当前元素存放的位置（n指的是数组的长度），如果当前元素存在元素，就判断该元素与要存入元素的hash值以及key是否相同，如果相同，直接覆盖，如果不同就通过拉链法解决。</p><p>JDK1.8之后，当链表长度大于等于阈值（默认为8）（将链表转为红黑树前会判断，如果当前数组的长度小于64，那么会选择先进行数组扩容，而不是转换为红黑树）时，将链表转化为红黑树，以减少搜索时间。</p><p>HashMap默认的初始化大小为16，之后每次扩充，容量变为原来的2倍。并且，HashMap总是使用2的幂作为哈希表的大小。</p><ul><li><p>loadFactor负载因子<br>负载因子控制数组存放数据的疏密程度，0.75f是官方给出的比较好的临界值。太大导致查找元素效率低，太小导致数组的利用率低</p></li><li><p>threshold<br>threshold&#x3D;capacity * loadFactor，当size &gt; threshold，考虑数组的扩增</p></li></ul><h3 id="扩容："><a href="#扩容：" class="headerlink" title="扩容："></a>扩容：</h3><p>超过最大值就不再扩容，直接返回table</p><p>没超过最大值，扩充为原来的两倍，threshold也是两倍</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><p>由很多个Segment组合，每个Segment类似于HashMap结构，HashMap内部可以进行扩容，但是Segment的个数一旦初始化就不变化。（Segment默认16，可以认为ConcurrentHashMap默认支持16个线程并发）</p><p>使用分段锁，每个Segment上同时只有一个线程可以操作。</p><h3 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h3><p>Node数组+链表&#x2F;红黑树，当冲突链表达到一定长度时，链表会转换成红黑树</p><p>使用Synchronized锁加CAS的机制</p><h2 id="CopyOnWriteArrayList"><a href="#CopyOnWriteArrayList" class="headerlink" title="CopyOnWriteArrayList"></a>CopyOnWriteArrayList</h2><p>JDK1.5引入了Java.util.concurrent(JUC)包，其中提供了很多线程安全且并发性能良好的容器，其中唯一的线程安全List实现就是CopyOnWriteArrayList。</p><p>写时复制。CopyOnWriteArrayList中的读取操作完全无需加锁，写入操作也不会阻塞读操作，只有写写才会互斥。</p><p>当需要修改（add，set，remove等操作）CopyOnWriteArrayList的内容时，不会直接修改原数组，而是会先创建底层数组的副本，对副本数组进行修改，修改完之后再将修改后的数组赋值回去。</p><p>适合读多写少的并发场景。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;ArrayList&quot;&gt;&lt;a href=&quot;#ArrayList&quot; class=&quot;headerlink&quot; title=&quot;ArrayList&quot;&gt;&lt;/a&gt;ArrayList&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    <category term="Java" scheme="https://sgnyyyy.github.io/categories/Java/"/>
    
    
  </entry>
  
  <entry>
    <title>排序算法整理</title>
    <link href="https://sgnyyyy.github.io/2024/12/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>https://sgnyyyy.github.io/2024/12/26/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E6%95%B4%E7%90%86/</id>
    <published>2024-12-26T05:46:53.000Z</published>
    <updated>2025-02-17T13:25:18.838Z</updated>
    
    <content type="html"><![CDATA[<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>最好情况O(nlogn),最坏情况 $O(n^2)$ ，平均情况O(nlogn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid = <span class="built_in">partition</span>(l, r, nums);</span><br><span class="line">    <span class="comment">//递归排序左边和右边</span></span><br><span class="line">    <span class="built_in">quickSort</span>(mid+<span class="number">1</span>, r, nums);</span><br><span class="line">    <span class="built_in">quickSort</span>(l, mid<span class="number">-1</span>, nums);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> pivot = nums[l]; <span class="comment">//以最左边元素为基准</span></span><br><span class="line">    <span class="keyword">while</span>(l &lt; r)&#123;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[r] &gt;= pivot) r--;</span><br><span class="line">        nums[l] = nums[r];</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r &amp;&amp; nums[l] &lt;= pivot) l++;</span><br><span class="line">        nums[r] = nums[l];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[l] = pivot;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">quickSort</span>(<span class="number">0</span>, n<span class="number">-1</span>, nums);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="type">int</span> mid = <span class="built_in">partition</span>(l, r, nums);</span><br><span class="line">        <span class="built_in">quickSort</span>(mid+<span class="number">1</span>, r, nums);</span><br><span class="line">        <span class="built_in">quickSort</span>(l, mid<span class="number">-1</span>, nums);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">rand</span>() % (r - l + <span class="number">1</span>) + l; <span class="comment">// 随机选一个作为我们的主元</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[r], nums[i]);</span><br><span class="line">        <span class="type">int</span> pivot = nums[r];</span><br><span class="line">        i = l<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = l;j &lt; r;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt; pivot)&#123;</span><br><span class="line">                i = i+<span class="number">1</span>;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i],nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i = i+<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[r]);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">quickSort</span>(<span class="number">0</span>, n<span class="number">-1</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>最好情况下O(nlogn)，最坏情况下O(nlogn)，平均情况下O(nlogn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; tmp;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="type">int</span> mid = (l+r)&gt;&gt;<span class="number">1</span>;</span><br><span class="line">        <span class="built_in">mergeSort</span>(l, mid, nums);</span><br><span class="line">        <span class="built_in">mergeSort</span>(mid+<span class="number">1</span>, r, nums);</span><br><span class="line">        <span class="type">int</span> i = l, j = mid+<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> k = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &lt;= nums[j])&#123;</span><br><span class="line">                tmp[k++] = nums[i++];</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                tmp[k++] = nums[j++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i &lt;= mid)&#123;</span><br><span class="line">            tmp[k++] = nums[i++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j &lt;= r)&#123;</span><br><span class="line">            tmp[k++] = nums[j++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i &lt; r-l+<span class="number">1</span>;i++)&#123;</span><br><span class="line">            nums[i+l] = tmp[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        tmp.<span class="built_in">resize</span>(n);</span><br><span class="line">        <span class="built_in">mergeSort</span>(<span class="number">0</span>, n<span class="number">-1</span>, nums);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>最好情况下O(nlogn)，最坏情况下O(nlogn)，平均情况下O(nlogn)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> len = nums.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//先建一个大根堆</span></span><br><span class="line">    <span class="built_in">buildMaxHeap</span>(nums, len);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = len;i &gt;= <span class="number">1</span>; --i)&#123;</span><br><span class="line">        <span class="comment">//将堆顶和最后一个元素交换位置</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[<span class="number">0</span>]);</span><br><span class="line">        len -= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//最后i个已经排好序，将前len-i个继续建一个大根堆，重复以上过程</span></span><br><span class="line">        <span class="built_in">maxHeapify</span>(nums,<span class="number">0</span>,len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildMaxHeap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//从最后一个父节点开始判断，让每个父节点都大于自己的孩子节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = len / <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="built_in">maxHeapify</span>(nums, i, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">maxHeapify</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> i, <span class="type">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// for循环递归调整受影响的子树</span></span><br><span class="line">    <span class="keyword">for</span> (; (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span> &lt;= len;) &#123;</span><br><span class="line">        <span class="type">int</span> lson = (i &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> rson = (i &lt;&lt; <span class="number">1</span>) + <span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> large;</span><br><span class="line">        <span class="keyword">if</span> (lson &lt;= len &amp;&amp; nums[lson] &gt; nums[i]) &#123;</span><br><span class="line">            large = lson;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            large = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rson &lt;= len &amp;&amp; nums[rson] &gt; nums[large]) &#123;</span><br><span class="line">            large = rson;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (large != i) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[large]);</span><br><span class="line">            i = large;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">heapSort</span>(nums);</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;冒泡排序&quot;&gt;&lt;a href=&quot;#冒泡排序&quot; class=&quot;headerlink&quot; title=&quot;冒泡排序&quot;&gt;&lt;/a&gt;冒泡排序&lt;/h2&gt;&lt;h2 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://sgnyyyy.github.io/2023/02/23/hello-world/"/>
    <id>https://sgnyyyy.github.io/2023/02/23/hello-world/</id>
    <published>2023-02-23T08:53:12.000Z</published>
    <updated>2022-03-11T00:42:02.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for</summary>
      
    
    
    
    
  </entry>
  
</feed>
